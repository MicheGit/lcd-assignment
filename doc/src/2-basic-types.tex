\section{Types}

\subsection{Basic types}

\begin{frame}{Basic Types - Syntax}
    % TODO split in due colonne, riportare in una quella originale di vasconcelos e nell'altra quella implementata
    Implementation of qualifier, pretypes and types are fully compliant to Chapter 3's original syntax:
    \begin{minipage}{\textwidth}
        \begin{minipage}{0.45\textwidth}
            \begin{flalign*}
                q ::= & lin \\
                & un \\
                p ::= & ?T.T \\
                & !T.T \\
            \end{flalign*}
        \end{minipage}
        \begin{minipage}{0.45\textwidth}
            \begin{flalign*}
                T :== & bool \\
                & end \\
                & q p \\
                \Gamma ::= & \emptyset \\
                & \Gamma , x : T 
            \end{flalign*}
        \end{minipage}
    \end{minipage}
    Contexts are implemented as hash maps of types
\end{frame}

\begin{frame}[fragile]{Basic Types - Duality}
    Duality is partially defined as follows:
    \begin{minted}{hs}
    dualType :: SpiType -> SpiType
    dualType End = End
    dualType Boolean = error "..."
    dualType (Qualified q (Receiving t1 t2)) = 
        Qualified q (Sending t1 (dualType t2))
    dualType (Qualified q (Sending t1 t2)) = 
        Qualified q (Receiving t1 (dualType t2))
    dualType (Recursive a p) = Recursive a (dualType p)
    dualType (TypeVar x) = TypeVar 
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Basic Types - Context}
    Contexts support the following operations:
    \begin{itemize}
        \item (nondeterministic) \textbf{context split} $\Gamma = \Gamma_1 \circ \Gamma_2$: the function \texttt{ndsplit :: Context -> [(Context, Context)]} creates all possible combinations of dividing \texttt{lin}ear variables, mantaining \texttt{un}restricted variables;
        \item \textbf{update} $\Gamma + (x : T)$: the function \texttt{update k t} inserts $k : t$ in the context only if the variable $k$ was not present, or it was yet defined \texttt{un}restricted with type $t$;
        \item \textbf{override} $\Gamma, (x : T)$: this represents newly bounded variables, possibly shadowing preexisting definitions.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic Types - Typing Rules (1)}

    Sequent calculus rules are modeled as instnces of the context transition \textbf{monad}:

    \begin{minted}{hs}
newtype CT a = CT 
    (Context -> TypeErrorBundle TypeError (a, Context))

instance Monad CT where
    return :: a -> CT a
    (>>=) :: CT a -> (a -> CT b) -> CT b
\end{minted}
    Rules can be composed and propagate context side effects

    A check rule can either hold and return \texttt{()} or fail and return an error:
    \begin{minted}{hs}
class TypeCheck a where
    check :: a -> CT ()
    \end{minted}

\end{frame}

\begin{frame}[fragile]{Basic Types - Typing Rules (2)}

    \begin{exampleblock}{Unrestricted requirement}
        $\texttt{un}(\Gamma)$ holds when all entries in the context are unrestricted:
\vspace{0.5cm}
        \begin{minted}{hs}
unGamma :: CT ()
unGamma = CT (\context -> if all unrestricted context
    then Right ((), context)
    else Left "Error message...")  
        \end{minted}
    \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Basic Types - Typing Rules (3)}

    \begin{exampleblock}{Context update}
        $\Gamma + (x : T)$ throws an error if the conditions arent met:
        \small\begin{minted}[escapeinside=//,mathescape=true]{hs}
update :: String -> SpiType -> CT ()
update k t = do
    may <- liftPure (M.lookup k)
    case may of
        Just found -> unless (predicate Un t && found /$\approx$/ t) 
            (throwError "Error message..")
        Nothing    -> sideEffect (M.insert k t)
        \end{minted}
    \end{exampleblock}
    
\end{frame}


\begin{frame}[fragile]{Basic Types - Typing Rules (4)}

    \begin{exampleblock}{Context update}
        Context transitions can even return useful values:
        \small\begin{minted}{hs}
extract :: String -> CT SpiType
extract k = do
    t <- get k
    unless (predicate Un t) (delete k)
    return t
        \end{minted}
    \end{exampleblock}

    This is used to optimize some context splits in the [\textsc{T-Rec}] and [\textsc{T-Send}] rules

\end{frame}

\begin{frame}{Basic Types - Typing Rules (5)}
    Context split require to nondeterministically check over all possible split if there is one that satisfies the rule.

    \vspace{1cm}

    Chapter 8 ``Algorithmic type checking'' shows a set of equivalent rules that can be checked with a deterministic algorithm.
\end{frame}
\begin{frame}{Basic Types - Typing Rules (6)}
    \begin{exampleblock}{Example: \textsc{T-In}}
        \begin{flalign*}
            \begin{prooftree}
                \hypo{\Gamma_1 \vdash x : q?T.U}
                \hypo{(\Gamma_2 + x : U), y : T \vdash P}
                \infer2[[\textsc{T-In}]]{\Gamma_1 \circ \Gamma_2 \vdash x(y).P}
            \end{prooftree}
        \end{flalign*}
    \end{exampleblock}
    In this case the rule holds following those observations:
    \begin{itemize}
        \item if $x$ is not present in $\Gamma_1 \circ \Gamma_2$ the left assumption can never be verified;
        \item if $\Gamma_1 \circ \Gamma_2$ contains the claim $x : \texttt{un} T.U$, then both $\Gamma_1,\Gamma_2$ contain such claim;
        \item if $\Gamma_1 \circ \Gamma_2$ contains the claim $x : \texttt{lin} T.U$, then $\Gamma_1$ must contain that claim and $\Gamma_2$ must not.
    \end{itemize}
\end{frame}

\begin{frame}{Basic Types - Typing Rules (7)}
    Notice that in order to type $\Gamma_1 \vdash x : q?T.U$, as for the rule [\textsc{T-Var}], $\Gamma_1$ must not contain any linear claim.
    
    \vspace{1cm}

    Hence, $\Gamma_2$ must contain all linear claims in $\Gamma_1 \circ \Gamma_2$, of course except for $x$ if it was linear.
\end{frame}

\begin{frame}[fragile]{Basic Types - Typing Rules (8)}
    Hence the algorithm for this rule is presented as follows:
    \begin{exampleblock}{Example: \textsc{T-In}}
        \begin{minted}{hs}
check (Rec x y p) = do
    xType <- extract x -- If not present, the monadic
        -- bind will make the whole rule fail.
        -- The function extract will preserve
        -- 
    (t, u) = case xType of 
            Qualified _ (Receiving t u) -> 
                return (t, u)
            _ -> throwError "..."
    update x u
    replace y t
    check p
        \end{minted}
    \end{exampleblock}
\end{frame}

\begin{frame}{Basic Types - Fir}
    Other typing rules implementations follow similar reasoning.

    \vspace{0.5cm}

    One could think of an intuitive way to parallelize the [\textsc{T-Par}]:

    \begin{exampleblock}{[\textsc{T-Par}]}
        \begin{flalign*}
            \begin{prooftree}
                \hypo{\Gamma_1 \vdash P_1}
                \hypo{\Gamma_2 \vdash P_2}
                \infer2[[\textsc{T-Par}]]{\Gamma_1 \circ \Gamma_2 \vdash P_1 | P_2} 
            \end{prooftree}
        \end{flalign*}
    \end{exampleblock}

\end{frame}

\begin{frame}[fragile]{Algorithmic Type Checking - First attempt (2)}
    The algorithm checks all possible splits of $\Gamma_1 \circ \Gamma_2$
    \small\begin{minted}{hs}
check (Par p1 p2) = do
    splits <- liftPure ndsplit 
    -- Compute all possible splits
    runs <- return () -< (candidate <$> splits)
    liftEither $ foldChoice runs 
        {- `using` parList rdeepseq -}
    where
        candidate (c1, c2) = (return () -< 
            [ c1 |> check p1
            , c2 |> check p2 
            ] {- <&> (`using` parList rdeepseq) -} 
            ) >- return ()
    \end{minted}
    It seems natural to desire to parallelize this code in the points with comments...
\end{frame}

\begin{frame}[fragile]{Basic Types - Typing Rules (11)}
    
    ... but this would imply loss in performance. Consider the following program:
    \begin{exampleblock}{Example: \texttt{assets/well-formed-ill-typed/multiple.spi}}
\tiny\begin{lstlisting}{language=pilang}
a1 >< a2: lin?bool.end .
b1 >< b2: lin?bool.end .
c1 >< c2: lin?bool.end .
d1 >< d2: lin?bool.end .
e1 >< e2: lin?bool.end .
f1 >< f2: lin?bool.end .
x >< y: rec x. ?bool.x .
    x1 >< y1: lin?bool.lin!bool.end .
        x2 >< y2: lin?bool.lin!bool.end .
            { x << true . y >> z . if z then 0 else 0
            | y >> z . if z
                then x << false . 0
                else 0
            | x1 << true . x1 >> n . y2 >> n . y2 << n .0
            | y1 >> n . y1 << false . x2 << false . x2 >> n .0
            | a1 << true . b1 << true . c1 << true 
                . d1 << true . e1 << true . f1 << true . 0
            | a2 >> e . b2 >> e . c2 >> e . d2 >> e . e2 >> e . 
                0
            }
        \end{lstlisting}
    \end{exampleblock}
\end{frame}

\begin{frame}{}
    Running the program 
    \begin{minipage}{0.45\textwidth}
        \small\texttt{SPARKS: 651264 (0 converted, 58321 overflowed, 0 dud, 429960 GC'd, 15527 fizzled)}
        
        \small\begin{tabular}{cccc}
            INIT    & time &    0.001s &  (  0.001s elapsed) \\
            MUT     & time &    2.987s &  (  2.981s elapsed) \\
            GC      & time &    3.961s &  (  3.972s elapsed) \\
            EXIT    & time &    0.000s &  (  0.007s elapsed) \\
            Total   & time &    6.949s &  (  6.961s elapsed)
        \end{tabular}
        
      
    \end{minipage}
    \begin{minipage}{0.45\textwidth}
        SPARKS: 3540338 (98151 converted, 87210 overflowed, 0 dud, 2443757 GC'd, 632692 fizzled)
      
        INIT    time    0.002s  (  0.002s elapsed)
        MUT     time   23.487s  (  6.104s elapsed)
        GC      time   29.159s  (  9.701s elapsed)
        EXIT    time    0.071s  (  0.004s elapsed)
        Total   time   52.720s  ( 15.811s elapsed)
      
    \end{minipage}

\end{frame}