\section{Structure}

\subsection*{Session Types}

\begin{frame}{Session Types}
    The paper \emph{Fundamentals of Session Types} % TODO impara a fare le references [1]
    presents a $\pi$-calculus equipped with a (linear) type system to check against errors that the system can incur into.

    Such language features linear types, which allow checking whether a given channel is used by exactly one process.
\end{frame}

\begin{frame}{Session Types - The $\pi$-calculus}
    This $\pi$-calculus' features are incrementtally presented through five sections:
    \begin{itemize}
        \item \textbf{basics and fundamentals} features, as scope restriction, in sections 2 and 3;
        \item \textbf{recursive types}, needed to write useful unrestricted types, in section 4;
        \item \textbf{unbounded computations}, in section 5, that enable infinite behaviours;
        \item \textbf{branching and selection}, in section 6 (not implemented).
    \end{itemize}

    The implementation process follows this very same organization, and will be presented accordingly.
\end{frame}

\subsection*{Software features}

\begin{frame}{Software features}
    The software is written in Haskell and it features:
    \begin{itemize}
        \item a \textbf{code interpreter}, that executes the code in Concurrent Haskell;
        \item a \textbf{type checker}, parallelized using the \texttt{Eval} monad;
        \item a type inferrer.
    \end{itemize}

    The paper has several examples of the expected behaviour of the type checker, that are implemented here as unit tests to avoid regressions.
\end{frame}



